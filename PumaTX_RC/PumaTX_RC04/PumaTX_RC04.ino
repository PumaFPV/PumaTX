/*TO-DO
 * 1- Make OTA timeout if no wifi instead of rebooting the ESP32 (OTA is now turned off)
 * 2- Soft Power
 * Turn off OTA via menu
 * Make navigation easier
 * Make calibration easier (Menu-> Calibrate -> press once, calibrate, press to stop calibration)

 */

extern const char* ssid = "NICOLASDG";
extern const char* password = "Nico1809";



#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>
#include <EEPROM.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include "MLX.h"

#include "OTA.h"
#include "Battery.h"
#include "Buttons.h"
#include "ComputeRCData.h"
#include "Navigation.h"
#include "SBus.h"
#include "SH1106.h"
#include "ShowSketchName.h"
#include "SoftPower.h"

MLX mlx(0x0C, 0x0D);  //Left, Right
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
//--------------------------------------------------S-BUS--------------------------------------------------
#define RC_CHANNEL_MIN -100  
#define RC_CHANNEL_MAX 100   

#define SBUS_MIN_OFFSET 173
#define SBUS_MID_OFFSET 992
#define SBUS_MAX_OFFSET 1811
#define SBUS_CHANNEL_NUMBER 16
#define SBUS_PACKET_LENGTH 25
#define SBUS_FRAME_HEADER 0x0f
#define SBUS_FRAME_FOOTER 0x00
#define SBUS_FRAME_FOOTER_V2 0x04
#define SBUS_STATE_FAILSAFE 0x08
#define SBUS_STATE_SIGNALLOSS 0x04
#define SBUS_UPDATE_RATE 15 //ms  

uint8_t sbusPacket[SBUS_PACKET_LENGTH];
int rcChannels[SBUS_CHANNEL_NUMBER];
uint32_t sbusTime = 0;


//--------------------------------------------------struct--------------------------------------------------
extern typedef struct Channel {    
  int Reading;  //from -10000 to 10000
  int Min;  //MLX Scale
  int Max;  //MLX Scale
  int Trim; //MLX Scale
  int Output; //-100 to 100
  int SBus;
  const uint8_t EepromAddrMin;
  const uint8_t EepromAddrMax;
  const uint8_t EepromAddrTrim;
  uint8_t EepromMin;
  uint8_t EepromMax;
  uint8_t EepromTrim;
  bool reverse;
};

extern typedef struct Button {
  uint8_t Pin;
  int State;
  int Output;
  int Prev;
};

extern typedef struct ADC {
  uint8_t Pin;
  float State;
  int Output;
};

extern typedef struct Graph {
  int x;
  int y;
};

Channel Throttle = {0, 0, 0, 0, 0, 992, 1, 2, 3, 0, 0, 0, 0};
Channel Yaw = {0, 0, 0, 0, 0, 992, 4, 5, 6, 0, 0, 0, 0};
Channel Pitch = {0, 0, 0, 0, 0, 992, 7, 8, 9, 0, 0, 0, 0};
Channel Roll = {0, 0, 0, 0, 0, 992, 10, 11, 12, 0, 0, 0, 0};

Button Right = {32, 1, 1, 1};
Button Left = {33, 1, 1, 1};
Button Up = {25, 1, 1, 1};
Button Down = {26, 1, 1, 1};
Button Ok = {27, 1, 1, 1};
Button RTH = {14, 1, -100, 1};
Button Pause = {13, 1, -100, 1};
Button Pwr = {4, 1, 1, 1};  //
Button Arm = {12, 1, -100, 1};
Button Pre = {15, 1, -100, 1};
Button LED = {2, 1, 1, 1};
//Button C1 = {pin, 1, 1, 1};
//Button C2 = {pin, 1, 1, 1};

extern ADC Voltage = {A7, 0.00, 0}; //GPIO35
extern ADC LeftPot = {A6, 0.0, 0};  //GPIO34
extern ADC RightPot = {A3, 0.0, 0}; //GPIO39

extern Graph LeftJoy = {0, 0};
extern Graph RightJoy = {0, 0};


//--------------------------------------------------VARIABLE--------------------------------------------------
extern bool calibrate = 0;

extern unsigned long lastdebouncetime = 0;
extern unsigned long debouncedelay = 50;
extern unsigned long currenttime = 0;

extern int page = 0;
extern int MaxPage = 5;

extern int HallSensorMin = -10000;
extern int HallSensorMax = 10000;

extern bool ScreenPwr;
extern unsigned long Now;

extern String Firmware;


//--------------------------------------------------BITMAP--------------------------------------------------

extern static const unsigned char Puma[] PROGMEM = {
  0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xF0, 0x06, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0x01, 0xF8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x66, 0x03, 
  0x68, 0x31, 0x00, 0x00, 0x00, 0x80, 0xD3, 0x06, 0x6C, 0x63, 0x00, 0x00, 
  0x00, 0xC0, 0xD8, 0x06, 0x24, 0xC6, 0x00, 0xF8, 0x03, 0x60, 0x8C, 0x04, 
  0x26, 0x0C, 0xE3, 0xFF, 0xFF, 0x19, 0x84, 0x0C, 0x36, 0x08, 0xFE, 0x40, 
  0xE0, 0x0F, 0x82, 0x0D, 0x32, 0xD0, 0x1D, 0x40, 0x00, 0x77, 0x83, 0x09, 
  0x12, 0x70, 0x7C, 0x40, 0xC0, 0xCF, 0x81, 0x09, 0x06, 0x3E, 0xCE, 0x40, 
  0x60, 0x8E, 0x8F, 0x0D, 0x9C, 0x1B, 0x9B, 0x41, 0x30, 0x9B, 0x39, 0x07, 
  0xF8, 0x18, 0x39, 0x43, 0x98, 0x9B, 0xE3, 0x03, 0x30, 0x2C, 0x3D, 0x4C, 
  0x86, 0x92, 0x06, 0x03, 0x10, 0xAC, 0x29, 0x58, 0x83, 0xB2, 0x04, 0x01, 
  0x30, 0xA6, 0x68, 0xE0, 0xC1, 0xA2, 0x8C, 0x01, 0x30, 0xE6, 0x68, 0xF8, 
  0xC3, 0xE2, 0x8C, 0x01, 0x70, 0x62, 0xC8, 0x5F, 0x7E, 0xC2, 0xC8, 0x00, 
  0x70, 0x63, 0xC8, 0x40, 0x60, 0xC2, 0xD8, 0x00, 0x70, 0x71, 0xC8, 0x40, 
  0x40, 0xC0, 0xD3, 0x01, 0xE0, 0x5D, 0x68, 0x40, 0xE0, 0x42, 0xF6, 0x00, 
  0xC0, 0x43, 0xA8, 0x40, 0xA0, 0x62, 0x78, 0x00, 0xC0, 0xC0, 0xB0, 0x41, 
  0xA0, 0x63, 0x60, 0x00, 0xC0, 0x80, 0xB0, 0x41, 0xB0, 0x23, 0x60, 0x00, 
  0x40, 0x80, 0x99, 0x41, 0x30, 0x33, 0x40, 0x00, 0x40, 0xFE, 0x1B, 0x41, 
  0x10, 0xFB, 0x4F, 0x00, 0xC0, 0xC3, 0x18, 0x41, 0x10, 0x63, 0x7C, 0x00, 
  0xC0, 0x40, 0x30, 0x41, 0x90, 0x41, 0x40, 0x00, 0xC0, 0x60, 0x30, 0x40, 
  0x98, 0xC1, 0x60, 0x00, 0xC0, 0xE0, 0x2F, 0x43, 0x98, 0xFE, 0x60, 0x00, 
  0xC0, 0xB1, 0x7F, 0x42, 0xD8, 0xBF, 0x61, 0x00, 0xC0, 0xB9, 0xF9, 0x46, 
  0xCC, 0x93, 0x73, 0x00, 0xC0, 0xB7, 0xC7, 0xFE, 0x6F, 0xBC, 0x7F, 0x00, 
  0x80, 0xB3, 0xE7, 0xF3, 0xF9, 0xBC, 0x39, 0x00, 0x80, 0x73, 0xBC, 0xC1, 
  0xF8, 0xC7, 0x19, 0x00, 0x80, 0x67, 0x8C, 0xA1, 0x30, 0x86, 0x3D, 0x00, 
  0x80, 0x2D, 0x0C, 0xB1, 0x11, 0x86, 0x35, 0x00, 0x00, 0x19, 0x98, 0x19, 
  0x33, 0x8F, 0x33, 0x00, 0x00, 0x3B, 0x96, 0x09, 0x22, 0x8D, 0x1B, 0x00, 
  0x00, 0x32, 0xB6, 0x0C, 0x66, 0x8D, 0x09, 0x00, 0x00, 0x66, 0xF6, 0x04, 
  0xC4, 0xC9, 0x0C, 0x00, 0x00, 0x6C, 0x62, 0x06, 0xC8, 0xC8, 0x06, 0x00, 
  0x00, 0xD8, 0x63, 0x03, 0xF8, 0x78, 0x03, 0x00, 0x00, 0x10, 0x33, 0x01, 
  0xB0, 0x19, 0x01, 0x00, 0x00, 0x30, 0x13, 0x01, 0x10, 0x9B, 0x01, 0x00, 
  0x00, 0xC0, 0x8B, 0x01, 0x30, 0xFA, 0x00, 0x00, 0x00, 0xC0, 0x8E, 0x01, 
  0x30, 0x6E, 0x00, 0x00, 0x00, 0x80, 0x86, 0x01, 0x30, 0x2C, 0x00, 0x00, 
  0x00, 0x80, 0x87, 0x05, 0x30, 0x38, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 
  0x1F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF3, 0x19, 0x18, 0x00, 0x00, 
  0x00, 0x00, 0xC3, 0x0E, 0x7C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x1C, 
  0xC6, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x18, 0x03, 0x0E, 0x00, 0x00, 
  0x00, 0x00, 0x04, 0xF0, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x40, 
  0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0xE0, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0xFC, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};




//===============================================================================================================================================================================================================
//----------------------------------------------------------------------------------------------------SETUP------------------------------------------------------------------------------------------------------
//===============================================================================================================================================================================================================
void setup(void){
  
  Wire.begin();   // Initialise I2C communication as MASTER
  Serial.begin(115200);  //Initialise Serial 1
  EEPROM.begin(12); //Initialise EEPROM and Ask for 12 addresses
  u8g2.begin(); //Initialise SH1106
  mlx.begin();  //Initialise MLX

  FirstBoot();
  ShowSketchName(); 
  OTASetup();
  PinModeDef();
  ReadEEPROM();  
  SBusInit();

  esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 0);
  
}

void loop(void){
  
  ArduinoOTA.handle();
  mlx.process();
  GetMLXData();
  Calibrate();
  //ComputeRC();
  ComputeRC2();
  ProcessButtons();
  SBus();
  Navigation();
  //OptimizeScreenUsage();
  Screen();
  ReadVoltage();
  Serial.println(Pwr.State);

}

void FirstBoot(){
  
    EEPROM.write(Throttle.EepromAddrMin, 250);    //EEPROM.write(Address, Value(from 0 to 255));
    EEPROM.write(Throttle.EepromAddrMax, 10);
    EEPROM.write(Throttle.EepromAddrTrim, 124);
    
    EEPROM.write(Yaw.EepromAddrMin, 250);
    EEPROM.write(Yaw.EepromAddrMin, 10);
    EEPROM.write(Yaw.EepromAddrTrim, 124);
    
    EEPROM.write(Pitch.EepromAddrMin, 250);
    EEPROM.write(Pitch.EepromAddrMax, 10);
    EEPROM.write(Pitch.EepromAddrTrim, 124);
    
    EEPROM.write(Roll.EepromAddrMin, 250);
    EEPROM.write(Roll.EepromAddrMax, 10); 
    EEPROM.write(Roll.EepromAddrTrim, 124);

    EEPROM.commit();
    
}


void ShowSketchName(){
  
    String path = __FILE__;
    int slash = path.lastIndexOf('\x5C');
    String the_cpp_name = path.substring(slash+1);
    int dot_loc = the_cpp_name.lastIndexOf('.');
    Firmware = the_cpp_name.substring(0, dot_loc);
    //Serial.println(Firmware);
    
}

void ReadEEPROM(){
  
  Throttle.Min = map(EEPROM.read(Throttle.EepromAddrMin), 0, 255, HallSensorMin, HallSensorMax);
  Throttle.Max = map(EEPROM.read(Throttle.EepromAddrMax), 0, 255, HallSensorMin, HallSensorMax);
  Throttle.Trim = map(EEPROM.read(Throttle.EepromAddrTrim), 0, 255, HallSensorMin, HallSensorMax);
  Yaw.Min = map(EEPROM.read(Yaw.EepromAddrMin), 0, 255, HallSensorMin, HallSensorMax);
  Yaw.Max = map(EEPROM.read(Yaw.EepromAddrMax), 0, 255, HallSensorMin, HallSensorMax);
  Yaw.Trim = map(EEPROM.read(Yaw.EepromAddrTrim), 0, 255, HallSensorMin, HallSensorMax);
  Pitch.Min = map(EEPROM.read(Pitch.EepromAddrMin), 0, 255, HallSensorMin, HallSensorMax);
  Pitch.Max = map(EEPROM.read(Pitch.EepromAddrMax), 0, 255, HallSensorMin, HallSensorMax);
  Pitch.Trim = map(EEPROM.read(Pitch.EepromAddrTrim), 0, 255, HallSensorMin, HallSensorMax);
  Roll.Min = map(EEPROM.read(Roll.EepromAddrMin), 0, 255, HallSensorMin, HallSensorMax);
  Roll.Max = map(EEPROM.read(Roll.EepromAddrMax), 0, 255, HallSensorMin, HallSensorMax);
  Roll.Trim = map(EEPROM.read(Roll.EepromAddrTrim), 0, 255, HallSensorMin, HallSensorMax);  
  
}

void GetMLXData(){
  
  Throttle.Reading = mlx.getThrottle();
  Yaw.Reading = mlx.getYaw();
  Pitch.Reading = mlx.getPitch();
  Roll.Reading = mlx.getRoll();
  
}
